function scatter_sums(x, y) {
// generated by Bing GPT
  var n = x.length;
  var sum_x = 0;
  var sum_y = 0;
  var sum_xy = 0;
  var sum_xx = 0;
  var sum_yy = 0;

  for (var i = 0; i < n; i++) {
    var xi = x[i];
    var yi = y[i];
    sum_x += xi;
    sum_y += yi;
    sum_xy += xi * yi;
    sum_xx += xi * xi;
    sum_yy += yi * yi;
  }

 return {n:n,sum_x : sum_x, sum_y: sum_y, sum_xx :sum_xx, sum_yy: sum_yy, sum_xy:sum_xy}
}
function correlation(sums) {

  var denominator = Math.sqrt(sums.sum_xx * sums.n - sums.sum_x * sums.sum_x) * Math.sqrt(sums.sum_yy * sums.n - sums.sum_y * sums.sum_y);
  if (denominator == 0) return 0;

  return (sums.sum_xy * sums.n - sums.sum_x * sums.sum_y) / denominator;
}

function regression_line(sums) {
   var y_bar = sums.sum_y / sums.n;
   var x_bar = sums.sum_x / sums.n;  
   var b= (sums.sum_xy - (sums.sum_x * sums.sum_y) / sums.n) / (sums.sum_xx - (sums.sum_x * sums.sum_x) / sums.n);
   var a = y_bar - b * x_bar;  
   return {x_bar :x_bar, y_bar: y_bar, a : a, b: b}   
}

function scatter_residuals(x, y, a, b) {

  var n = x.length;
  var sum_y_diff = 0;
  var sum_y_diff_2 = 0;

  for (var i = 0; i < n; i++) {
    var xi = x[i];
    var yi = y[i];
    var y_est = a + b * xi;
    var y_diff = yi - y_est;    
    sum_y_diff += y_diff;
    sum_y_diff_2 += y_diff * y_diff ;
   }

 return {sum_y_diff: sum_y_diff,sum_y_diff_2: sum_y_diff_2}
}


function scatter_diffs(x, y, x_bar, y_bar) {

  var n = x.length ;
  var sum_x_diff_2 = 0;
  var sum_y_diff_2 = 0;

  for (var i = 0; i < n; i++) {
    var xi = x[i];
    var yi = y[i];
   
    var x_diff = xi - x_bar;    
    var y_diff = yi - y_bar;    
    sum_x_diff_2 += x_diff * x_diff;
    sum_y_diff_2 += y_diff * y_diff ;
   }

 return {sum_x_diff_2: sum_x_diff_2,sum_y_diff_2: sum_y_diff_2}
}

function fisher_trans(r) {
   return  0.5 * Math.log((1 + r)/ (1 - r));
}

function fisher_inv(f) {
    return (Math.exp(2 * f) - 1) / (Math.exp(2 * f) + 1);
}

function fisher_CI(r,n,k) {
   F_mean = fisher_trans(r);
   F_se = 1.0 / Math.sqrt(n - 3);
   lower = fisher_inv(F_mean - k * F_se);
   upper = fisher_inv(F_mean + k * F_se);
   sig =  (lower < 0 && upper > 0 ) ? "Non-SIg" : "Sig" ;
   return {lower: lower , upper: upper, sig :sig };   
}

/**
 * Groups allocation data into bins based on the difference between 'simd' and 'imd' scores.
 * This is a JavaScript implementation of the provided XQuery snippet.
 *
 * @param {Array<Object>} allocations - An array of allocation objects. Each object must have 'simd' and 'imd' numeric properties.
 * @param {number} width - The size of each bin for grouping the differences.
 * @returns {Object} An object representing the histogram, where keys are the start of each bin and values are the counts.
 */
function groupDifferences(allocations, width) {
  if (!allocations || allocations.length === 0 || !width) {
    return {};
  }

  // Corresponds to: let $gdiffs := $allocations/allocation/(floor((simd - imd) div $width))
  const gdiffs = allocations
    .filter(alloc => typeof alloc.simd === 'number' && typeof alloc.imd === 'number')
    .map(alloc => {
      const diff = alloc.simd - alloc.imd;
      return Math.floor(diff / width);
    });

  if (gdiffs.length === 0) {
    return {};
  }

  // Corresponds to: for $g in $min to $max let $n := count($gdiffs[.=$g]) return ...
  const grouped = gdiffs.reduce((acc, g) => {
    const binStart = g * width;
    acc[binStart] = (acc[binStart] || 0) + 1;
    return acc;
  }, {});

  return grouped;
}